# The following class defines a node in a Fibonacci binary tree. 
define a class: FibNode:
  define a constructor that takes the instance of the object itself and a value n:
    let self.data be n
	let self.left node be None
	let self.right node be None

# The following function builds a Fibonacci binary tree of order n and returns a node with pointers.
define a function: buildFibTree, with the input the order n:
  # The base case: when the order is 0 or 1
  if n is 0 or n is 1:
    let node be FibNode(n)
	return node
  # The recursive process: when the order is greater than 1
  else:
    let node be FibNode(n)
	let node.left be buildFibTree(n-1)
	let node.right be buildFibTree(n-2)
	return node

"""""

# The following function makes a new right in-threaded binary tree using the sequential array representation.
define a function: MakeTree, with the input: n (the expected number of nodes), m (the value of the root):
  return a sequentail array of n null items with the value of the first item being m # The position of the first item is 0.

# The following function sets the left child node of a given node.
define a function: SetLeft, with the input: array (the sequential array), i (the position of an existing node), m (the value of the set node):
  if array[i] is null:
    print("Error: The parent node does not exist.") # The parent node must exist.
  else:
    if array[2i+1] is not null:
	  print("Error: The parent node already has a left node.") # We only set a new node, instead of replacing a curret node.
	else:
	  let array[2i+1] be m # Since the right in-threaded binary tree uses the sequential array implementation, by default the right pointer of the left child of a parent is to this parent, and the right tread is true. This implies array[2i+1]'s right pointer is to array[i].
  
# The following function sets the right child node of a given node.
define a function: SetRight, with the input: array (the sequential array), i (the position of an existing node), m (the value of the set node):
  if array[i] is null:
    print("Error: The parent node does not exist.") # The parent node must exist.
  else:
    if array[2i+2] is not null:
	  print("Error: The parent node already has a right node.") # We only set a new node, instead of replacing a curret node.
	else:
	  let array[2i+2] be m # Since the right in-threaded binary tree uses the sequential array implementation, by default the right pointer of the right child of a parent is to this parent's right pointer, and the right tread is true. This implies array[2i+2]'s right pointer is array[i]'s right pointer.

"""""

# The following function returns a list of values with inorder traversal from a right in-threaded binary tree using the sequential array representation with recurssion.
define a function: InOrderTraverse, with the input: array (the current sequential array), i (the position of the current node, being 0 by default), list (the list that stores the values, being empty by default):
  # The stop case is when all values of the array have been removed.
    if all items in array are null:
      return list
  # The recursive process
    else:
	  # If value at the current is null, it moves to its parent. This process finds the nearest ancestor of the current node.
	  if array[i] is null:
	    return InOrderTraverse(i/2, array, list)
	  else:
	    # If the current node is a leaf, i.e. no left child and no right child, the function returns its value and moves to its nearest ancestor.
	    # After the value at current node is read and appended to the list, the value in the array is removed.
        if array[2i+1] is null and array[2i+2] is null:
          return InOrderTraverse(i/2, array[:i]+array[i+1:], list.append(array[i]))
	    # If the current node has a left child, no matter whether it has a right child, the function moves to its left child.
	    if array[2i+1] is not null:
	      return InOrderTraverse(2i+1, array, list)
	    # If the current node has no left child and has a right child, the function moves to its right child.
	    else:
	      return InOrderTraverse(2i+2, array, list)