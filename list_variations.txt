# The following function inserts a new node to the left end of a deque implemented as a doubly-linked list.
define a function, with the input: list (a doubly-linked list), newNode (an item to insert to the left):
  # If the list is empty, simply make the list's head and pointers to the new node
  if list->head is null:
	let list->head be newNode
	let list->tail be newNode
  else:
    # Let the original left first ndoe be the successor ndoe of the new node.
    let sucNode be list->head
	# Only change the successor node's previous node into the new node.
    # The successor node's next node stays the same.
	let sucNode->prev be newNode
	# Set the new node's pointers, i.e. its location.
	let newNode->next be sucNode
	let newNode->prev be null
	# Make the list's head pointer to the new node. 
	let list->head be newNode
  
  return list

# The following function deletes the node at the right end of a deque implemented as a doubly-linked list.
define a function, with the input: list (a doubly-linked list):
  # If the list is empty, do nothing.
  # Only consider the condition when the list is not empty.
  if list->head is not null:
    # Make the list's rightmost node as curNode.
	let curNode be list->tail
    # By changing the pointers to curNode, remove it.
	# Change the pointer of the predecessor node.
	let predNode be curNode->prev
	let predNode->next be null
	# Change the tail pointer of the list.
	let list->tail be predNode
  
  return list

""""""

# The following function inserts a new node to the right end of a deque implemented as a doubly-linked circular list with a header.
define a function, with the input: list (a doubly-linked circular list), newNode (an item to insert to the right):
  # Since there is a header, the list is not empty.
  # Set the predecessor node, which could be the header.
  let predNode be list->head->prev
  # Simply insert the new node to the tail of the list and make its previous pointer to the predecessor node and the next pointer to the header.
  let newNode->prev be predNode
  let newNode->next be list->head
  # Change the pointers of the adjacent nodes to the new node.
  let header->prev be newNode
  let predNode->next be newNode
  
  return list

# The following function deletes the node at the left end of a deque implemented as a doubly-linked circular list with a header.
define a function, with the input: list (a doubly-linked circular list):
  # Since there is a header, the list is not empty.
  # However, if the header is the only node, do nothing.
  # Only consider the condition when where are other nodes besides the header.
  if header->next is not header:
    # Set the successor node, which could be the header.
    let sucNode be list->head->next->next
    # Simply delete the node to the head of the list by changing the pointers of the adjacent nodes.
    let list->head->next be sucNode
    let sucNode->prev be list->head
 
  return list